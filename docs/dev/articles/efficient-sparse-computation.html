<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Using memory-efficient sparse computations • fastadi</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Using memory-efficient sparse computations">
<meta property="og:description" content="fastadi">
<meta name="robots" content="noindex">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">fastadi</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="In-development version">0.1.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/adaptive-impute.html">An introduction to AdaptiveInitialize and AdaptiveImpute</a>
    </li>
    <li>
      <a href="../articles/efficient-sparse-computation.html">Using memory-efficient sparse computations</a>
    </li>
    <li>
      <a href="../articles/sparse-matrix-intro.html">Introduction to sparse computations</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/RoheLab/fastadi/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Using memory-efficient sparse computations</h1>
                        <h4 class="author">Alex Hayes</h4>
            
            <h4 class="date">2020-09-22</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/RoheLab/fastadi/blob/master/vignettes/efficient-sparse-computation.Rmd"><code>vignettes/efficient-sparse-computation.Rmd</code></a></small>
      <div class="hidden name"><code>efficient-sparse-computation.Rmd</code></div>

    </div>

    
    

<div id="low-rank-implementation" class="section level2">
<h2 class="hasAnchor">
<a href="#low-rank-implementation" class="anchor"></a>Low-rank implementation</h2>
<p>The reference implementation has some problems. As our data matrix <span class="math inline">\(M\)</span> gets larger, we can no longer fit the dense representation of <span class="math inline">\(\hat M\)</span> and <span class="math inline">\(Z^{(t)}\)</span> into memory. Instead, we need to work with just the low rank components <span class="math inline">\(\hat \lambda, \hat U\)</span> and <span class="math inline">\(\hat V\)</span>.</p>
<p>This leads us to following implementation:</p>
<div class="sourceCode" id="cb1"><html><body><pre class="r"><span class="no">low_rank_adaptive_initialize</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">M</span>, <span class="no">r</span>) {

  <span class="no">M</span> <span class="kw">&lt;-</span> <span class="fu">as</span>(<span class="no">M</span>, <span class="st">"dgCMatrix"</span>)

  <span class="no">p_hat</span> <span class="kw">&lt;-</span> <span class="fu">nnzero</span>(<span class="no">M</span>) / <span class="fu"><a href="https://rdrr.io/r/base/prod.html">prod</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="no">M</span>))  <span class="co"># line 1</span>

  <span class="co"># NOTE: skip explicit computation of line 2</span>
  <span class="co"># NOTE: skip explicit computation of line 3</span>

  <span class="no">eig_p</span> <span class="kw">&lt;-</span> <span class="fu">eigen_helper</span>(<span class="no">M</span>, <span class="no">r</span>)
  <span class="no">eig_t</span> <span class="kw">&lt;-</span> <span class="fu">eigen_helper</span>(<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">M</span>), <span class="no">r</span>)

  <span class="no">lr_v_hat</span> <span class="kw">&lt;-</span> <span class="no">eig_p</span>$<span class="no">vectors</span>  <span class="co"># line 4</span>
  <span class="no">lr_u_hat</span> <span class="kw">&lt;-</span> <span class="no">eig_t</span>$<span class="no">vectors</span>  <span class="co"># line 5</span>

  <span class="no">d</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span>(<span class="no">M</span>)
  <span class="no">n</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span>(<span class="no">M</span>)

  <span class="co"># NOTE: alpha is again incorrect since we work with eigenvalues</span>
  <span class="co"># rather than singular values here</span>
  <span class="no">sum_eigen_values</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">M</span>@<span class="kw">x</span>^<span class="fl">2</span>) / <span class="no">p</span>^<span class="fl">2</span> - (<span class="fl">1</span> - <span class="no">p</span>) * <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/colSums.html">colSums</a></span>(<span class="no">M</span>^<span class="fl">2</span>))
  <span class="no">lr_alpha</span> <span class="kw">&lt;-</span> (<span class="no">sum_eigen_values</span> - <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">eig_p</span>$<span class="no">values</span>)) / (<span class="no">d</span> - <span class="no">r</span>)  <span class="co"># line 6</span>

  <span class="no">lr_lambda_hat</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span>(<span class="no">eig_p</span>$<span class="no">values</span> - <span class="no">lr_alpha</span>) / <span class="no">p_hat</span>  <span class="co"># line 7</span>

  <span class="co"># TODO: Karl had another sign computation here that he said was faster</span>
  <span class="co"># but it wasn't documented anywhere, so I'm going with what was in the </span>
  <span class="co"># paper</span>

  <span class="no">lr_svd_M</span> <span class="kw">&lt;-</span> <span class="fu">svds</span>(<span class="no">M</span>, <span class="no">r</span>)

  <span class="co"># v_hat is d by r</span>
  <span class="no">lr_v_sign</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/crossprod.html">crossprod</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">1</span>, <span class="no">d</span>), <span class="no">lr_svd_M</span>$<span class="no">v</span> * <span class="no">lr_v_hat</span>)
  <span class="no">lr_u_sign</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/crossprod.html">crossprod</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">1</span>, <span class="no">n</span>), <span class="no">lr_svd_M</span>$<span class="no">u</span> * <span class="no">lr_u_hat</span>)
  <span class="no">lr_s_hat</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/sign.html">sign</a></span>(<span class="no">lr_v_sign</span> * <span class="no">lr_u_sign</span>))  <span class="co"># line 8</span>

  <span class="no">lr_lambda_hat</span> <span class="kw">&lt;-</span> <span class="no">lr_lambda_hat</span> * <span class="no">lr_s_hat</span>

  <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">u</span> <span class="kw">=</span> <span class="no">lr_u_hat</span>, <span class="kw">d</span> <span class="kw">=</span> <span class="no">lr_lambda_hat</span>, <span class="kw">v</span> <span class="kw">=</span> <span class="no">lr_v_hat</span>)
}</pre></body></html></div>
<p>What does <code>eigen_helper()</code> do? Describe the return object (also do this for svds)</p>
<div class="sourceCode" id="cb2"><html><body><pre class="r"><span class="co"># Take the eigendecomposition of t(M) %*% M - (1 - p) * diag(t(M) %*% M)</span>
<span class="co"># using sparse computations only</span>
<span class="no">eigen_helper</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">M</span>, <span class="no">r</span>) {
  <span class="fu">eigs_sym</span>(
    <span class="no">Mx</span>, <span class="no">r</span>,
    <span class="kw">n</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span>(<span class="no">M</span>),
    <span class="kw">args</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(
      <span class="kw">M</span> <span class="kw">=</span> <span class="no">M</span>,
      <span class="kw">p</span> <span class="kw">=</span> <span class="fu">nnzero</span>(<span class="no">M</span>) / <span class="fu"><a href="https://rdrr.io/r/base/prod.html">prod</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="no">M</span>))
    )
  )
}

<span class="co"># compute (t(M) %*% M / p^2 - (1 - p) * diag(diag(t(M) %*% M))) %*% x</span>
<span class="co"># using sparse operations</span>

<span class="co"># TODO: divide the second term by p^2 like in the reference implementatio</span>
<span class="no">Mx</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">x</span>, <span class="no">args</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/drop.html">drop</a></span>(
    <span class="fu"><a href="https://rdrr.io/r/base/crossprod.html">crossprod</a></span>(<span class="no">args</span>$<span class="no">M</span>, <span class="no">args</span>$<span class="no">M</span> <span class="kw">%*%</span> <span class="no">x</span>) / <span class="no">args</span>$<span class="no">p</span>^<span class="fl">2</span> - (<span class="fl">1</span> - <span class="no">args</span>$<span class="no">p</span>) * <span class="fu">Diagonal</span>(<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span>(<span class="no">args</span>$<span class="no">M</span>), <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">colSums</a></span>(<span class="no">args</span>$<span class="no">M</span>^<span class="fl">2</span>)) <span class="kw">%*%</span> <span class="no">x</span>
  )
}</pre></body></html></div>
<p>Now we check that <code>Mx</code> works</p>
<div class="sourceCode" id="cb3"><html><body><pre class="r"><span class="no">x</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">12</span>)
<span class="no">p</span> <span class="kw">&lt;-</span> <span class="fl">0.3</span>
<span class="no">out</span> <span class="kw">&lt;-</span> (<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">M</span>) <span class="kw">%*%</span> <span class="no">M</span> / <span class="no">p</span>^<span class="fl">2</span> - (<span class="fl">1</span> - <span class="no">p</span>) * <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">M</span>) <span class="kw">%*%</span> <span class="no">M</span>))) <span class="kw">%*%</span> <span class="no">x</span>
<span class="no">out2</span> <span class="kw">&lt;-</span> <span class="fu">Mx</span>(<span class="no">x</span>, <span class="kw">args</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">M</span> <span class="kw">=</span> <span class="no">M</span>, <span class="kw">p</span> <span class="kw">=</span> <span class="no">p</span>))
<span class="fu"><a href="https://rdrr.io/r/base/all.equal.html">all.equal</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span>(<span class="no">out</span>), <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span>(<span class="no">out</span>))</pre></body></html></div>
</div>
<div id="check-the-computation-of-alpha-for-p-s-d--matrices" class="section level1">
<h1 class="hasAnchor">
<a href="#check-the-computation-of-alpha-for-p-s-d--matrices" class="anchor"></a>check the computation of alpha for p.s.d. matrices</h1>
<div class="sourceCode" id="cb4"><html><body><pre class="r"><span class="no">S</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/toeplitz.html">toeplitz</a></span>((<span class="fl">10</span>:<span class="fl">1</span>)/<span class="fl">10</span>)
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="fl">11</span>)
<span class="no">R</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/rWishart.html">rWishart</a></span>(<span class="fl">1</span>, <span class="fl">20</span>, <span class="no">S</span>)[, ,<span class="fl">1</span>]
<span class="no">R</span>

<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">R</span>))
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span>(<span class="no">R</span>)$<span class="no">values</span>)
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/svd.html">svd</a></span>(<span class="no">R</span>)$<span class="no">d</span>)

<span class="no">p</span> <span class="kw">&lt;-</span> <span class="fl">0.5</span>

<span class="no">X</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/crossprod.html">crossprod</a></span>(<span class="no">R</span>) - (<span class="fl">1</span> - <span class="no">p</span>) * <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/crossprod.html">crossprod</a></span>(<span class="no">R</span>))


<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">X</span>))
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/eigen.html">eigen</a></span>(<span class="no">X</span>)$<span class="no">values</span>)
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/svd.html">svd</a></span>(<span class="no">X</span>)$<span class="no">d</span>)</pre></body></html></div>
<div class="sourceCode" id="cb5"><html><body><pre class="r"><span class="no">M</span> <span class="kw">&lt;-</span> <span class="no">ml100k</span>
<span class="no">s</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/svd.html">svd</a></span>(<span class="no">M</span>)</pre></body></html></div>
<div class="sourceCode" id="cb6"><html><body><pre class="r"><span class="co"># nuclear norm</span>
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">s</span>$<span class="no">d</span>)
<span class="fu"><a href="https://rdrr.io/r/base/norm.html">norm</a></span>(<span class="no">M</span>, <span class="kw">type</span> <span class="kw">=</span> <span class="st">"F"</span>)

<span class="no">r</span> <span class="kw">&lt;-</span> <span class="fl">5</span>

<span class="no">d</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span>(<span class="no">M</span>)
<span class="no">n</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span>(<span class="no">M</span>)

<span class="no">alpha</span> <span class="kw">&lt;-</span> (<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">s</span>$<span class="no">d</span>) - <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">s</span>$<span class="no">d</span>[<span class="fl">1</span>:<span class="no">r</span>])) / (<span class="no">d</span> - <span class="no">r</span>)
<span class="no">alpha</span>

<span class="no">s</span>$<span class="no">d</span>[<span class="fl">1</span>:<span class="no">r</span>]</pre></body></html></div>
<p>TODO: update alg description to divide by <span class="math inline">\(p^2\)</span> to get the right singular values</p>
<p>Quickly check that the components works before we try the code that integrates them all together</p>
<p>Finally, sanity check this by comparing to the reference implementation. These don’t agree, which isn’t great:</p>
<div class="sourceCode" id="cb7"><html><body><pre class="r"><span class="no">lr_init</span> <span class="kw">&lt;-</span> <span class="fu">sparse_adaptive_initialize</span>(<span class="no">dat</span>, <span class="no">r</span>)

<span class="co"># some weird stuff is happening with the singular values but I'm</span>
<span class="co"># going to not worry about it for the time being</span>

<span class="fu">equal_svds</span>(<span class="no">init</span>, <span class="no">lr_init</span>)</pre></body></html></div>
<div id="space-efficient-adaptive-impute" class="section level2">
<h2 class="hasAnchor">
<a href="#space-efficient-adaptive-impute" class="anchor"></a>Space-efficient adaptive impute</h2>
<p>TODO: figure out the actual space complexity</p>
<p>Recall the algorithm looks like</p>
<p><span class="math display">\[\begin{align}
\hat M = \sum_{i=1}^r \hat s_i  \hat \lambda_i \hat U_i \hat V_i^T
\end{align}\]</span></p>

<p>Now we need two things:</p>
<ol style="list-style-type: decimal">
<li>The SVD of <span class="math inline">\(\tilde M^{(t)}\)</span>
</li>
<li>(Certain sums of) the squared singular values.</li>
</ol>
<div id="sums-of-squared-singular-values" class="section level3">
<h3 class="hasAnchor">
<a href="#sums-of-squared-singular-values" class="anchor"></a>Sums of squared singular values</h3>
<p>For a matrix <span class="math inline">\(A\)</span>, the sum of squared singular values (denoted by <span class="math inline">\(\lambda_i\)</span>) equals the squared frobenius norm:</p>
<p><span class="math display">\[\begin{align}
\sum_{i=1}^{\min(n, d)} \lambda_i^2 = ||A||_F^2 = \mathop\mathrm{trace}(A^T A)
\end{align}\]</span></p>
<p>Also note that</p>
<p><span class="math display">\[\begin{align}
||A + B||_F^2 = ||A||_F^2 + ||B||_F^2 + 2 \cdot \langle A, B \rangle_F
\end{align}\]</span></p>
<p>Now we consider <span class="math inline">\(\tilde M^{(t)}\)</span>. Suppose that unobserved values of <span class="math inline">\(M\)</span> are set to zero, as is the case for <span class="math inline">\(M\)</span> stored in a sparse matrix representation</p>
<p><span class="math display">\[\begin{align}
\tilde M^{(t)} &amp;= P_\Omega(M) + P_\Omega^\perp (Z_t) \\
&amp;= P_\Omega(M) + P_\Omega^\perp \left(
  \sum_{i=1}^r \hat \lambda_i^{(t)} \hat U_i^{(t)} \hat V_i^{(t)^T}
  \right)
\end{align}\]</span></p>
<p>Now we need</p>
<p><span class="math display">\[\begin{align}
||\tilde M^{(t)}||_F^2 
&amp;= \left \Vert
  P_\Omega(M) + P_\Omega^\perp \left(
    \sum_{i=1}^r \hat \lambda_i^{(t)} \hat U_i^{(t)} \hat V_i^{(t)^T}
    \right)
  \right \Vert_F^2 \\
&amp;= \left \Vert P_\Omega(M) \right \Vert_F^2 
  + \left \Vert P_\Omega^\perp \left(
      \sum_{i=1}^r \hat \lambda_i^{(t)} \hat U_i^{(t)} \hat V_i^{(t)^T}
    \right)
  \right \Vert_F^2
  + 2 \cdot \left \langle P_\Omega(M), P_\Omega^\perp \left(
      \sum_{i=1}^r \hat \lambda_i^{(t)} \hat U_i^{(t)} \hat V_i^{(t)^T}
    \right) \right \rangle_F \\
&amp;= \left \Vert P_\Omega(M) \right \Vert_F^2 
  + \left \Vert P_\Omega^\perp \left(
      \sum_{i=1}^r \hat \lambda_i^{(t)} \hat U_i^{(t)} \hat V_i^{(t)^T}
    \right)
  \right \Vert_F^2
\end{align}\]</span></p>
<p>Where the cancellation in the final line follows because</p>
<p><span class="math display">\[\begin{align}
\left \langle P_\Omega(M), P_\Omega^\perp
  \left(
    \sum_{i=1}^r \hat \lambda_i^{(t)} \hat U_i^{(t)} \hat V_i^{(t)^T}
  \right)
\right \rangle_F
= \sum_{i, j} P_\Omega(M)_{ij} \cdot P_\Omega^\perp (Z_t)_{ij}
= \sum_{i, j} 0
= 0
\end{align}\]</span></p>
<p>Now we need one more trick, which is that</p>
<p><span class="math display">\[\begin{align}
\left \Vert Z_t \right \Vert_F^2
= \left \Vert P_\Omega (Z_t) + P_\Omega^\perp (Z_t) \right \Vert_F^2
= \left \Vert P_\Omega (Z_t) \right \Vert_F^2 + 
  \left \Vert P_\Omega^\perp (Z_t) \right \Vert_F^2
\end{align}\]</span></p>
<p>and then</p>
<p><span class="math display">\[\begin{align}
\left \Vert P_\Omega^\perp (Z_t) \right \Vert_F^2
= \left \Vert Z_t \right \Vert_F^2
  - \left \Vert P_\Omega (Z_t) \right \Vert_F^2 \\
= \sum_{i = 1}^r \lambda_i^2 - \left \Vert Z_t \odot Y \right \Vert_F^2
\end{align}\]</span></p>
<p>Putting it all together we see</p>
<p><span class="math display">\[\begin{align}
||\tilde M^{(t)}||_F^2 
&amp;= \left \Vert P_\Omega(M) \right \Vert_F^2 
  + \left \Vert P_\Omega^\perp \left(
      \sum_{i=1}^r \hat \lambda_i^{(t)} \hat U_i^{(t)} \hat V_i^{(t)^T}
    \right)
  \right \Vert_F^2 \\
&amp;= \left \Vert M \right \Vert_F^2 + 
  \sum_{i = 1}^r \lambda_i^2 - 
  \left \Vert Z_t \odot Y \right \Vert_F^2
\end{align}\]</span></p>
<p>In code we will have a sparse matrix <code>M</code> and a list <code>s</code> with elements of the SVD. The first Frobenious norm is quick to calculate, but I am not sure how to calculate the other two frobenius norms.</p>
<div class="sourceCode" id="cb8"><html><body><pre class="r"><span class="co"># s is a matrix defined in terms of it's svd</span>
<span class="co"># G is a sparse matrix</span>
<span class="co"># compute only elements of U %*% diag(d) %*% t(V) only on non-zero elements of G</span>
<span class="co"># G and U %*% t(V) must have same dimensions</span>

<span class="co"># maybe call this svd_perp?</span>
<span class="no">svd_perp</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">s</span>, <span class="no">mask</span>) {

  <span class="co"># note: must be dgTMatrix to get column indexes j larger</span>
  <span class="co"># what if we used dlTMatrix here?</span>
  <span class="no">m</span> <span class="kw">&lt;-</span> <span class="fu">as</span>(<span class="no">mask</span>, <span class="st">"dgTMatrix"</span>)

  <span class="co"># the indices for which we want to compute the matrix multiplication</span>
  <span class="co"># turn zero based indices into one based indices</span>
  <span class="no">i</span> <span class="kw">&lt;-</span> <span class="no">m</span>@<span class="kw">i</span> + <span class="fl">1</span>
  <span class="no">j</span> <span class="kw">&lt;-</span> <span class="no">m</span>@<span class="kw">j</span> + <span class="fl">1</span>

  <span class="co"># gets rows and columns of U and V to multiply, then multiply</span>
  <span class="no">ud</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">u</span> <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">s</span>$<span class="no">d</span>)
  <span class="no">left</span> <span class="kw">&lt;-</span> <span class="no">ud</span>[<span class="no">i</span>, ]
  <span class="no">right</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">v</span>[<span class="no">j</span>, ]

  <span class="co"># compute inner products to get elements of U %*% t(V)</span>
  <span class="no">uv</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowSums</a></span>(<span class="no">left</span> * <span class="no">right</span>)

  <span class="co"># NOTE: specify dimensions just in case</span>
  <span class="fu">sparseMatrix</span>(<span class="kw">i</span> <span class="kw">=</span> <span class="no">i</span>, <span class="kw">j</span> <span class="kw">=</span> <span class="no">j</span>, <span class="kw">x</span> <span class="kw">=</span> <span class="no">uv</span>, <span class="kw">dims</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="no">mask</span>))
}</pre></body></html></div>
<p>Test it</p>
<div class="sourceCode" id="cb9"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="fl">17</span>)

<span class="no">M</span> <span class="kw">&lt;-</span> <span class="fu">rsparsematrix</span>(<span class="fl">8</span>, <span class="fl">12</span>, <span class="kw">nnz</span> <span class="kw">=</span> <span class="fl">30</span>)
<span class="no">s</span> <span class="kw">&lt;-</span> <span class="fu">svds</span>(<span class="no">M</span>, <span class="fl">5</span>)

<span class="no">y</span> <span class="kw">&lt;-</span> <span class="fu">as</span>(<span class="no">M</span>, <span class="st">"lgCMatrix"</span>)

<span class="no">Z</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">u</span> <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">s</span>$<span class="no">d</span>) <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">s</span>$<span class="no">v</span>)

<span class="fu"><a href="https://rdrr.io/r/base/all.equal.html">all.equal</a></span>(
  <span class="fu">svd_perp</span>(<span class="no">s</span>, <span class="no">M</span>),
  <span class="no">Z</span> * <span class="no">y</span>
)</pre></body></html></div>
<p>So, to take an eigendecomp you just need to be able to do <span class="math inline">\(Mx\)</span>. To take an SVD, what do you need? matrix vector and matrix transpose vector multiplication</p>
<div class="sourceCode" id="cb10"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="fl">17</span>)
<span class="no">r</span> <span class="kw">&lt;-</span> <span class="fl">5</span>

<span class="no">M</span> <span class="kw">&lt;-</span> <span class="fu">rsparsematrix</span>(<span class="fl">8</span>, <span class="fl">12</span>, <span class="kw">nnz</span> <span class="kw">=</span> <span class="fl">30</span>)
<span class="no">y</span> <span class="kw">&lt;-</span> <span class="fu">as</span>(<span class="no">M</span>, <span class="st">"lgCMatrix"</span>)

<span class="no">s</span> <span class="kw">&lt;-</span> <span class="fu">svds</span>(<span class="no">M</span>, <span class="no">r</span>)
<span class="no">Z</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">u</span> <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">s</span>$<span class="no">d</span>) <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">s</span>$<span class="no">v</span>)

<span class="no">M_tilde</span> <span class="kw">&lt;-</span> <span class="no">M</span> + <span class="no">Z</span> * (<span class="fl">1</span> - <span class="no">y</span>)  <span class="co"># dense!</span>

<span class="no">Z_perp</span> <span class="kw">&lt;-</span> <span class="fu">svd_perp</span>(<span class="no">s</span>, <span class="no">M</span>)
<span class="no">sum_singular_squared</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">M</span>@<span class="kw">x</span>^<span class="fl">2</span>) + <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">s</span>$<span class="no">d</span>^<span class="fl">2</span>) - <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">Z_perp</span>@<span class="kw">x</span>^<span class="fl">2</span>)

<span class="fu"><a href="https://rdrr.io/r/base/all.equal.html">all.equal</a></span>(
  <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/svd.html">svd</a></span>(<span class="no">M_tilde</span>)$<span class="no">d</span>^<span class="fl">2</span>),
  <span class="no">sum_singular_squared</span>
)</pre></body></html></div>
</div>
<div id="svd-of-m-tilde" class="section level3">
<h3 class="hasAnchor">
<a href="#svd-of-m-tilde" class="anchor"></a>SVD of M tilde</h3>
<div class="sourceCode" id="cb11"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="fl">17</span>)
<span class="no">r</span> <span class="kw">&lt;-</span> <span class="fl">5</span>

<span class="no">M</span> <span class="kw">&lt;-</span> <span class="fu">rsparsematrix</span>(<span class="fl">8</span>, <span class="fl">12</span>, <span class="kw">nnz</span> <span class="kw">=</span> <span class="fl">30</span>)
<span class="no">y</span> <span class="kw">&lt;-</span> <span class="fu">as</span>(<span class="no">M</span>, <span class="st">"lgCMatrix"</span>)

<span class="no">s</span> <span class="kw">&lt;-</span> <span class="fu">svds</span>(<span class="no">M</span>, <span class="no">r</span>)
<span class="no">Z</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">u</span> <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">s</span>$<span class="no">d</span>) <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">s</span>$<span class="no">v</span>)

<span class="no">M_tilde</span> <span class="kw">&lt;-</span> <span class="no">M</span> + <span class="no">Z</span> * (<span class="fl">1</span> - <span class="no">y</span>)  <span class="co"># dense!</span>

<span class="no">svd_M_tilde</span> <span class="kw">&lt;-</span> <span class="fu">svds</span>(<span class="no">M_tilde</span>, <span class="no">r</span>)
<span class="no">svd_M_tilde</span></pre></body></html></div>
<div class="sourceCode" id="cb12"><html><body><pre class="r"><span class="no">Ax</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">x</span>, <span class="no">args</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/drop.html">drop</a></span>(<span class="no">M_tilde</span> <span class="kw">%*%</span> <span class="no">x</span>)
}

<span class="no">Atx</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">x</span>, <span class="no">args</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/drop.html">drop</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">M_tilde</span>) <span class="kw">%*%</span> <span class="no">x</span>)
}

<span class="co"># is eigs_sym() with a two-sided multiply faster?</span>
<span class="no">args</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">u</span> <span class="kw">=</span> <span class="no">s</span>$<span class="no">u</span>, <span class="kw">d</span> <span class="kw">=</span> <span class="no">s</span>$<span class="no">d</span>, <span class="kw">v</span> <span class="kw">=</span> <span class="no">s</span>$<span class="no">v</span>, <span class="kw">m</span> <span class="kw">=</span> <span class="no">M</span>)
<span class="no">test1</span> <span class="kw">&lt;-</span> <span class="fu">svds</span>(<span class="no">Ax</span>, <span class="kw">k</span> <span class="kw">=</span> <span class="no">r</span>, <span class="kw">Atrans</span> <span class="kw">=</span> <span class="no">Atx</span>, <span class="kw">dim</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="no">M</span>), <span class="kw">args</span> <span class="kw">=</span> <span class="no">args</span>)

<span class="no">test1</span>
<span class="no">svd_M_tilde</span>

<span class="fu"><a href="https://rdrr.io/r/base/all.equal.html">all.equal</a></span>(
  <span class="no">svd_M_tilde</span>,
  <span class="no">test1</span>
)</pre></body></html></div>
<p>So we’re done our first sanity check of the function interface. Let <span class="math inline">\(x\)</span> be a vector. Now we want to calculate</p>
<p><span class="math display">\[\begin{align}
\tilde M^{(t)} x 
  &amp;= \left[ P_\Omega(M) + P_\Omega^\perp (Z_t) \right] x \\
  &amp;= \left[ P_\Omega(M) -
    P_\Omega (Z_t) +
    P_\Omega (Z_t) +
    P_\Omega^\perp (Z_t) \right] x \\
  &amp;= P_\Omega(M - Z_t) x + Z_t x
\end{align}\]</span></p>
<p>where we can think of <span class="math inline">\(R_t \equiv P_\Omega(M - Z_t)\)</span> as “residuals” of sorts. Crucially, <span class="math inline">\(R_t\)</span> is sparse, and</p>
<p><span class="math display">\[\begin{align}
Z_t x &amp;= (\hat U 
  \mathop\mathrm{diag}(\hat \lambda_1, ..., \hat \lambda_r)
  \hat V^t) x \\
  &amp;= (\hat U 
  (\mathop\mathrm{diag}(\hat \lambda_1, ..., \hat \lambda_r)
  (\hat V^t x)))
\end{align}\]</span></p>
<p>So now the memory requirement of the computation has been reduced to that of two sparse matrix vector multiplications, rather than that of fitting the dense matrix <span class="math inline">\(P_\Omega^\perp (Z_t)\)</span> into memory.</p>
<p>Similarly, for the transpose, we have</p>
<p><span class="math display">\[\begin{align}
\tilde M^{{(t)}^T} x 
  &amp;= \left[ P_\Omega(M) + P_\Omega^\perp (Z_t) \right]^T x \\
  &amp;= \left[ P_\Omega(M) -
    P_\Omega (Z_t) +
    P_\Omega (Z_t) +
    P_\Omega^\perp (Z_t) \right]^T x \\
  &amp;= P_\Omega(M - Z_t)^T x + Z_t^T x
\end{align}\]</span></p>
<p>This leads us to a second, less memory intensive implementation of <code>Ax()</code> and <code>Atx()</code>:</p>
<div class="sourceCode" id="cb13"><html><body><pre class="r"><span class="co"># input: M, Z_t as a low-rank SVD list s</span>

<span class="no">R</span> <span class="kw">&lt;-</span> <span class="no">M</span> - <span class="fu">svd_perp</span>(<span class="no">s</span>, <span class="no">M</span>)  <span class="co"># residual matrix</span>
<span class="no">args</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">u</span> <span class="kw">=</span> <span class="no">s</span>$<span class="no">u</span>, <span class="kw">d</span> <span class="kw">=</span> <span class="no">s</span>$<span class="no">d</span>, <span class="kw">v</span> <span class="kw">=</span> <span class="no">s</span>$<span class="no">v</span>, <span class="kw">R</span> <span class="kw">=</span> <span class="no">R</span>)

<span class="no">Ax</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">x</span>, <span class="no">args</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/drop.html">drop</a></span>(<span class="no">args</span>$<span class="no">R</span> <span class="kw">%*%</span> <span class="no">x</span> + <span class="no">args</span>$<span class="no">u</span> <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">args</span>$<span class="no">d</span>) <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/crossprod.html">crossprod</a></span>(<span class="no">args</span>$<span class="no">v</span>, <span class="no">x</span>))
}

<span class="no">Atx</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">x</span>, <span class="no">args</span>) {
  <span class="co"># TODO: can we use a crossprod() for the first multiplication here?</span>
  <span class="fu"><a href="https://rdrr.io/r/base/drop.html">drop</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">args</span>$<span class="no">R</span>) <span class="kw">%*%</span> <span class="no">x</span> + <span class="no">args</span>$<span class="no">v</span> <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">args</span>$<span class="no">d</span>) <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/crossprod.html">crossprod</a></span>(<span class="no">args</span>$<span class="no">u</span>, <span class="no">x</span>))
}

<span class="co"># is eigs_sym() with a two-sided multiply faster?</span>
<span class="no">test2</span> <span class="kw">&lt;-</span> <span class="fu">svds</span>(<span class="no">Ax</span>, <span class="kw">k</span> <span class="kw">=</span> <span class="no">r</span>, <span class="kw">Atrans</span> <span class="kw">=</span> <span class="no">Atx</span>, <span class="kw">dim</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="no">M</span>), <span class="kw">args</span> <span class="kw">=</span> <span class="no">args</span>)

<span class="fu"><a href="https://rdrr.io/r/base/all.equal.html">all.equal</a></span>(
  <span class="no">svd_M_tilde</span>,
  <span class="no">test2</span>
)</pre></body></html></div>
<div class="sourceCode" id="cb14"><html><body><pre class="r"><span class="no">relative_f_norm_change</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">s_new</span>, <span class="no">s</span>) {
  <span class="co"># TODO: don't do the dense calculation here</span>

  <span class="no">Z_new</span> <span class="kw">&lt;-</span> <span class="no">s_new</span>$<span class="no">u</span> <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">s_new</span>$<span class="no">d</span>) <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">s_new</span>$<span class="no">v</span>)
  <span class="no">Z_new</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">u</span> <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">s</span>$<span class="no">d</span>) <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">s</span>$<span class="no">v</span>)

  <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>((<span class="no">Z_new</span> - <span class="no">Z</span>)^<span class="fl">2</span>) / <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">Z</span>^<span class="fl">2</span>)
}</pre></body></html></div>
<div class="sourceCode" id="cb15"><html><body><pre class="r"><span class="no">sparse_adaptive_impute</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">M</span>, <span class="no">r</span>, <span class="no">epsilon</span> <span class="kw">=</span> <span class="fl">1e-03</span>) {

  <span class="co"># coerce M to sparse matrix such that we use sparse operations</span>
  <span class="no">M</span> <span class="kw">&lt;-</span> <span class="fu">as</span>(<span class="no">M</span>, <span class="st">"dgCMatrix"</span>)

  <span class="co"># low rank svd-like object, s ~ Z_1</span>
  <span class="no">s</span> <span class="kw">&lt;-</span> <span class="fu">sparse_adaptive_initialize</span>(<span class="no">M</span>, <span class="no">r</span>)  <span class="co"># line 1</span>
  <span class="no">delta</span> <span class="kw">&lt;-</span> <span class="fl">Inf</span>
  <span class="no">d</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span>(<span class="no">M</span>)
  <span class="no">norm_M</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">M</span>@<span class="kw">x</span>^<span class="fl">2</span>)

  <span class="kw">while</span> (<span class="no">delta</span> <span class="kw">&gt;</span> <span class="no">epsilon</span>) {

    <span class="co"># update s: lines 4 and 5</span>
    <span class="co"># take the SVD of M-tilde</span>

    <span class="no">R</span> <span class="kw">&lt;-</span> <span class="no">M</span> - <span class="fu">svd_perp</span>(<span class="no">s</span>, <span class="no">M</span>)  <span class="co"># residual matrix</span>
    <span class="no">args</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="kw">u</span> <span class="kw">=</span> <span class="no">s</span>$<span class="no">u</span>, <span class="kw">d</span> <span class="kw">=</span> <span class="no">s</span>$<span class="no">d</span>, <span class="kw">v</span> <span class="kw">=</span> <span class="no">s</span>$<span class="no">v</span>, <span class="kw">R</span> <span class="kw">=</span> <span class="no">R</span>)

    <span class="no">s_new</span> <span class="kw">&lt;-</span> <span class="fu">svds</span>(<span class="no">Ax</span>, <span class="kw">k</span> <span class="kw">=</span> <span class="no">r</span>, <span class="kw">Atrans</span> <span class="kw">=</span> <span class="no">Atx</span>, <span class="kw">dim</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="no">M</span>), <span class="kw">args</span> <span class="kw">=</span> <span class="no">args</span>)

    <span class="no">MtM</span> <span class="kw">&lt;-</span> <span class="no">norm_M</span> + <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">s_new</span>$<span class="no">d</span>^<span class="fl">2</span>) - <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="fu">svd_perp</span>(<span class="no">s_new</span>, <span class="no">M</span>)^<span class="fl">2</span>)
    <span class="no">alpha</span> <span class="kw">&lt;-</span> (<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">MtM</span>) - <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">s_new</span>$<span class="no">d</span>^<span class="fl">2</span>)) / (<span class="no">d</span> - <span class="no">r</span>)  <span class="co"># line 6</span>

    <span class="no">s_new</span>$<span class="no">d</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span>(<span class="no">s_new</span>$<span class="no">d</span>^<span class="fl">2</span> - <span class="no">alpha</span>)  <span class="co"># line 7</span>

    <span class="co"># NOTE: skip explicit computation of line 8</span>
    <span class="no">delta</span> <span class="kw">&lt;-</span> <span class="fu">relative_f_norm_change</span>(<span class="no">s_new</span>, <span class="no">s</span>)

    <span class="no">s</span> <span class="kw">&lt;-</span> <span class="no">s_new</span>

    <span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span>(<span class="kw pkg">glue</span><span class="kw ns">::</span><span class="fu"><a href="https://glue.tidyverse.org/reference/glue.html">glue</a></span>(<span class="st">"delta: {round(delta, 8)}, alpha: {round(alpha, 3)}"</span>))
  }

  <span class="no">s</span>
}</pre></body></html></div>
<div class="sourceCode" id="cb16"><html><body><pre class="r"><span class="no">out</span> <span class="kw">&lt;-</span> <span class="fu">sparse_adaptive_impute</span>(<span class="no">M</span>, <span class="no">r</span>)
<span class="no">out</span></pre></body></html></div>
<p><span class="math display">\[\begin{align}
\texttt{MtM} = \tilde M^{{(t)}^T} \tilde M^{(t)}
\end{align}\]</span></p>
</div>
</div>
<div id="extension-to-a-mixture-of-observed-and-unobserved-missingness" class="section level2">
<h2 class="hasAnchor">
<a href="#extension-to-a-mixture-of-observed-and-unobserved-missingness" class="anchor"></a>Extension to a mixture of observed and unobserved missingness</h2>
<p>originally solving an optimization vaguely of the form</p>
<p><span class="math display">\[\begin{align}
\left \Vert M - \hat M \right \Vert_F^2
\end{align}\]</span></p>
<p>where <span class="math inline">\(M\)</span> is a partially observed matrix. now, we let <span class="math inline">\(M' = Y M\)</span> where <span class="math inline">\(Y\)</span> is an indicator of whether or not <span class="math inline">\(M\)</span> was observed. Typically we have some setup like</p>
<p><span class="math display">\[\begin{align}
M = 
 \begin{bmatrix}
    \cdot &amp; \cdot &amp; 3     &amp; 1     &amp; \cdot \\
    3     &amp; \cdot &amp; \cdot &amp; 8     &amp; \cdot \\
    \cdot &amp; -1    &amp; \cdot &amp; \cdot &amp; \cdot \\
    \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
    \cdot &amp; 2     &amp; \cdot &amp; \cdot &amp; \cdot \\
    5     &amp; \cdot &amp; 7     &amp; \cdot &amp; 4
  \end{bmatrix}
, \qquad
Y = 
  \begin{bmatrix}
    \cdot &amp; \cdot &amp; 1     &amp; 1     &amp; \cdot \\
    1     &amp; \cdot &amp; \cdot &amp; 1     &amp; \cdot \\
    \cdot &amp; 1     &amp; \cdot &amp; \cdot &amp; \cdot \\
    \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
    \cdot &amp; 1     &amp; \cdot &amp; \cdot &amp; \cdot \\
    1     &amp; \cdot &amp; 1     &amp; \cdot &amp; 1
  \end{bmatrix}
\end{align}\]</span></p>
<p>Here the symbol <span class="math inline">\(\cdot\)</span> means that an entry of the matrix was unobserved.</p>
<p>but what we do now is, continuing to represent <span class="math inline">\(M\)</span> as a sparse matrix with no zero entries, is <em>observe</em> a bunch of zeros. So we might know that the upper triangule of <span class="math inline">\(M\)</span> has structurally missing zeros that we have observed are missing. These zeros are primarily important because they affect the residuals in our calculations. In this particular case, the take multiplication by <span class="math inline">\(M\)</span>, a sparse operation, and make it into a dense operation.</p>
<p>At this point it becomes useful to introduce some additional notation. Let <span class="math inline">\(\tilde \Omega\)</span> be the set of indicies <span class="math inline">\((i, j)\)</span> such that <span class="math inline">\(M_{i, j}\)</span> is non-zero. Observe that <span class="math inline">\(\tilde \Omega \subset \Omega\)</span>. Then we have <span class="math inline">\(P_{\tilde \Omega} (A) = P_\Omega (A)\)</span>.</p>
<p><span class="math display">\[\begin{align}
M = 
 \begin{bmatrix}
    0     &amp; 0     &amp; 3     &amp; 1     &amp; 0 \\
    3     &amp; 0     &amp; 0     &amp; 8     &amp; 0 \\
    \cdot &amp; -1    &amp; 0     &amp; 0     &amp; 0 \\
    \cdot &amp; \cdot &amp; \cdot &amp; 0     &amp; 0 \\
    \cdot &amp; 2     &amp; \cdot &amp; \cdot &amp; 0 \\
    5     &amp; \cdot &amp; 7     &amp; \cdot &amp; 4
  \end{bmatrix}
, \qquad
Y = 
  \begin{bmatrix}
    1     &amp; 1     &amp; 1     &amp; 1     &amp; 1 \\
    1     &amp; 1     &amp; 1     &amp; 1     &amp; 1 \\
    \cdot &amp; 1     &amp; 1     &amp; 1     &amp; 1 \\
    \cdot &amp; \cdot &amp; \cdot &amp; 1     &amp; 1 \\
    \cdot &amp; 1     &amp; \cdot &amp; \cdot &amp; 1 \\
    1     &amp; \cdot &amp; 1     &amp; \cdot &amp; 1
  \end{bmatrix}
, \qquad
M' = 
 \begin{bmatrix}
    \cdot &amp; \cdot &amp; 3     &amp; 1     &amp; \cdot \\
    3     &amp; \cdot &amp; \cdot &amp; 8     &amp; \cdot \\
    \cdot &amp; -1    &amp; \cdot &amp; \cdot &amp; \cdot \\
    \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
    \cdot &amp; 2     &amp; \cdot &amp; \cdot &amp; \cdot \\
    5     &amp; \cdot &amp; 7     &amp; \cdot &amp; 4
  \end{bmatrix}
\end{align}\]</span></p>
<p>And now we need to figure out how to calculate</p>
<p><span class="math display">\[\begin{align}
\tilde M^{(t)} x 
  &amp;= \left[ P_\Omega(M) + P_\Omega^\perp (Z_t) \right] x \\
  &amp;= \left[ P_\Omega(M) -
    P_\Omega (Z_t) +
    P_\Omega (Z_t) +
    P_\Omega^\perp (Z_t) \right] x \\
  &amp;= P_\Omega(M)  - P_\Omega(Z_t) x + Z_t x \\
  &amp;= P_{\tilde \Omega}(M)  - P_\Omega(Z_t) x + Z_t x
\end{align}\]</span></p>
<p>We already know how to calculate <span class="math inline">\(P_{\tilde \Omega}(M)\)</span> and <span class="math inline">\(Z_t x\)</span> using sparse operations, so we’re left with <span class="math inline">\(P_\Omega(Z_t) x\)</span>. Note that <span class="math inline">\(P_\Omega(Z_t) x \neq P_{\tilde \Omega} (Z_t) x\)</span> since <span class="math inline">\(Z_t\)</span> is not necessarily zero on <span class="math inline">\(\tilde \Omega^\perp\)</span>. In other words <span class="math inline">\(P_\Omega^\perp (Z_t) \neq Z_t\)</span>.</p>
<p>When <span class="math inline">\(Y\)</span> is dense, there is no way to avoid paying the computational cost of the dense or near dense computation. Our primary concern is fitting <span class="math inline">\(Y\)</span> into memory for large datasets. This is an issue when <span class="math inline">\(Y\)</span> is dense but with no discernible structure that permits a more compact representation.</p>
<p>If we can fit <span class="math inline">\(Y\)</span> into memory, we can do a low-rank computation, only calculating elements <span class="math inline">\(Z^{(t)}_{ij}\)</span> when <span class="math inline">\(Y_{ij} = 1\)</span>. When <span class="math inline">\(Y\)</span> is stored as a vector of row indices together with a vector of column indices (plus some information about the dimension), we can write the computation out:</p>
<div class="sourceCode" id="cb17"><html><body><pre class="r"><span class="no">M</span> <span class="kw">&lt;-</span> <span class="fu">Matrix</span>(
  <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span>(
    <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">3</span>, <span class="fl">1</span>, <span class="fl">0</span>),
    <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">3</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">8</span>, <span class="fl">0</span>),
    <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0</span>, -<span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>),
    <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>),
    <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0</span>, <span class="fl">2</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>),
    <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">5</span>, <span class="fl">0</span>, <span class="fl">7</span>, <span class="fl">0</span>, <span class="fl">4</span>)
  )
)

<span class="no">Y</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span>(
  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>),
  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>),
  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>),
  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>),
  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">1</span>),
  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1</span>)
)

<span class="no">s</span> <span class="kw">&lt;-</span> <span class="fu">svds</span>(<span class="no">M</span>, <span class="fl">2</span>)

<span class="no">Y</span> <span class="kw">&lt;-</span> <span class="fu">as</span>(<span class="no">Y</span>, <span class="st">"CsparseMatrix"</span>)

<span class="co"># triplet form</span>
<span class="co"># compressed column matrix form even better but don't</span>
<span class="co"># understand the format</span>
<span class="no">Y</span> <span class="kw">&lt;-</span> <span class="fu">as</span>(<span class="no">Y</span>, <span class="st">"lgCMatrix"</span>)
<span class="no">Y</span> <span class="kw">&lt;-</span> <span class="fu">as</span>(<span class="no">Y</span>, <span class="st">"lgTMatrix"</span>)

<span class="co"># ugh: RcppArmadillo only supports dgTMatrix rather than</span>
<span class="co"># lgTMatrix which is somewhat unfortunate</span>

<span class="co"># link: https://cran.r-project.org/web/packages/RcppArmadillo/vignettes/RcppArmadillo-sparseMatrix.pdf</span>

<span class="no">Y</span>

<span class="no">x</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span>(<span class="fl">5</span>)

<span class="co"># want to calculate</span>
<span class="no">Z</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">u</span> <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">s</span>$<span class="no">d</span>) <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">s</span>$<span class="no">v</span>)
<span class="no">out</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/drop.html">drop</a></span>((<span class="no">Z</span> * <span class="no">Y</span>) <span class="kw">%*%</span> <span class="no">x</span>)
<span class="no">out</span></pre></body></html></div>
<p>At this point it’s worth writing out explicitly how calculate <span class="math inline">\(Z^{(t)}_{ij}\)</span>.</p>
<p><span class="math display">\[\begin{align}
Z^{(t)}_{ij} 
&amp;= \left( \sum_{\ell=1}^r \hat U_\ell \hat d_\ell \hat V_\ell^T \right)_{ij}
\end{align}\]</span></p>
<p>For a visual reminder, this looks like (using <span class="math inline">\(\mathop\mathrm{diag}(\hat d)\)</span> and <span class="math inline">\(\hat \Sigma\)</span> somewhat interchangeably here)</p>
<p><span class="math display">\[\begin{align}
Z^{(t)}
= \hat U \mathop\mathrm{diag}(\hat d) \, \hat V^T
= 
\begin{bmatrix}
  U_1 &amp; U_2 &amp; \hdots &amp; U_r \\
\end{bmatrix}
\begin{bmatrix}
  d_{1} &amp; 0 &amp; \hdots &amp; 0 \\
  0 &amp; d_{2} &amp; \hdots &amp; 0 \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  0 &amp; 0 &amp; \hdots &amp; d_{r}
\end{bmatrix}
\begin{bmatrix}
  V_1^T \\
  V_2^T \\
  \vdots \\
  V_r^T
\end{bmatrix}
\end{align}\]</span></p>
<p><span class="math display">\[\begin{align}
\begin{bmatrix}
  U_{11} &amp; U_{12} &amp; \hdots &amp; U_{1r} \\
  U_{21} &amp; U_{22} &amp; \hdots &amp; U_{2r} \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  U_{n1} &amp; U_{n2} &amp; \hdots &amp; U_{nr}
\end{bmatrix}
\begin{bmatrix}
  d_{1} &amp; 0 &amp; \hdots &amp; 0 \\
  0 &amp; d_{2} &amp; \hdots &amp; 0 \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  0 &amp; 0 &amp; \hdots &amp; d_{r}
\end{bmatrix}
\begin{bmatrix}
  V_{11} &amp; V_{21} &amp; \hdots &amp; V_{d1} \\
  V_{12} &amp; V_{22} &amp; \hdots &amp; V_{d2} \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  V_{1r} &amp; V_{2r} &amp; \hdots &amp; V_{dr}
\end{bmatrix}
\end{align}\]</span></p>
<p>n x d = (n x r) x (r x r) x (r x d)</p>
<p>(r x d) is after the transpose</p>
<p><span class="math display">\[\begin{align}
\begin{bmatrix}
  U_{11} &amp; U_{12} &amp; \hdots &amp; U_{1r} \\
  U_{21} &amp; U_{22} &amp; \hdots &amp; U_{2r} \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  U_{n1} &amp; U_{n2} &amp; \hdots &amp; U_{nr}
\end{bmatrix}
\begin{bmatrix}
  d_{1} &amp; 0 &amp; \hdots &amp; 0 \\
  0 &amp; d_{2} &amp; \hdots &amp; 0 \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  0 &amp; 0 &amp; \hdots &amp; d_{r}
\end{bmatrix}
\begin{bmatrix}
  V_{11} &amp; V_{21} &amp; \hdots &amp; V_{d1} \\
  V_{12} &amp; V_{22} &amp; \hdots &amp; V_{d2} \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  V_{1r} &amp; V_{2r} &amp; \hdots &amp; V_{dr}
\end{bmatrix}
\end{align}\]</span></p>
<p>Also because I never remember anything, recall that <span class="math inline">\(Z\)</span> is <span class="math inline">\(n \times d\)</span>, <span class="math inline">\(x\)</span> is <span class="math inline">\(d \times 1\)</span> and <span class="math inline">\(Zx\)</span> is <span class="math inline">\(n \times 1\)</span>:</p>
<p><span class="math display">\[\begin{align}
(Zx)_i = \sum_{j=1}^d Z_{ij} \cdot x_j
\end{align}\]</span></p>
<p>(recall that <span class="math inline">\(X_i\)</span> always refers to the <span class="math inline">\(i^{th}\)</span> column of <span class="math inline">\(X\)</span> in this document)</p>
<div class="sourceCode" id="cb18"><html><body><pre class="r"><span class="co"># mask as a pair list</span>
<span class="co"># L and Z / svd are both n x d matrices</span>
<span class="co"># x is a d x 1 matrix / vector</span>
<span class="no">masked_svd_times_x</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">s</span>, <span class="no">mask</span>, <span class="no">x</span>) {

  <span class="fu"><a href="https://rdrr.io/r/base/stopifnot.html">stopifnot</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/class.html">inherits</a></span>(<span class="no">mask</span>, <span class="st">"lgTMatrix"</span>))

  <span class="no">u</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">u</span>
  <span class="no">d</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">d</span>
  <span class="no">v</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">v</span>

  <span class="no">zx</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">numeric</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span>(<span class="no">u</span>))

  <span class="co"># lgTMatrix uses zero based indexing, add one</span>
  <span class="no">row</span> <span class="kw">&lt;-</span> <span class="no">mask</span>@<span class="kw">i</span> + <span class="fl">1</span>
  <span class="no">col</span> <span class="kw">&lt;-</span> <span class="no">mask</span>@<span class="kw">j</span> + <span class="fl">1</span>

  <span class="co"># need to loop over index of indexes</span>
  <span class="co"># double looping over i and j here feels intuitive</span>
  <span class="co"># but is incorrect</span>
  <span class="kw">for</span> (<span class="no">idx</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq_along</a></span>(<span class="no">row</span>)) {
    <span class="no">i</span> <span class="kw">&lt;-</span> <span class="no">row</span>[<span class="no">idx</span>]
    <span class="no">j</span> <span class="kw">&lt;-</span> <span class="no">col</span>[<span class="no">idx</span>]

    <span class="no">z_ij</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">u</span>[<span class="no">i</span>, ] * <span class="no">d</span> * <span class="no">v</span>[<span class="no">j</span>, ])
    <span class="no">zx</span>[<span class="no">i</span>] <span class="kw">&lt;-</span> <span class="no">zx</span>[<span class="no">i</span>] + <span class="no">x</span>[<span class="no">j</span>] * <span class="no">z_ij</span>
  }

  <span class="no">zx</span>
}

<span class="co"># how to calculate just one element of the reconstructed</span>
<span class="co"># data using the SVD</span>

<span class="no">i</span> <span class="kw">&lt;-</span> <span class="fl">6</span>
<span class="no">j</span> <span class="kw">&lt;-</span> <span class="fl">4</span>

<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">s</span>$<span class="no">u</span>[<span class="no">i</span>, ] * <span class="no">s</span>$<span class="no">d</span> * <span class="no">s</span>$<span class="no">v</span>[<span class="no">j</span>, ])
<span class="no">Z</span>[<span class="no">i</span>, <span class="no">j</span>]

<span class="co"># the whole masked matrix multiply</span>

<span class="no">Z</span> <span class="kw">&lt;-</span> <span class="no">s</span>$<span class="no">u</span> <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span>(<span class="no">s</span>$<span class="no">d</span>) <span class="kw">%*%</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="no">s</span>$<span class="no">v</span>)
<span class="no">out</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/drop.html">drop</a></span>((<span class="no">Z</span> * <span class="no">Y</span>) <span class="kw">%*%</span> <span class="no">x</span>)

<span class="co"># check that we did this right</span>
<span class="fu"><a href="https://rdrr.io/r/base/all.equal.html">all.equal</a></span>(
  <span class="fu">masked_svd_times_x</span>(<span class="no">s</span>, <span class="no">Y</span>, <span class="no">x</span>),
  <span class="no">out</span>
)</pre></body></html></div>
<p>This is gonna be painfully slow in R so we rewrite in C++</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span></a>
<a class="sourceLine" id="cb19-2" title="2"></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="kw">using</span> <span class="kw">namespace</span> arma;</a>
<a class="sourceLine" id="cb19-4" title="4"></a>
<a class="sourceLine" id="cb19-5" title="5"><span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb19-7" title="7"></a>
<a class="sourceLine" id="cb19-8" title="8">vec masked_svd_times_x_impl(</a>
<a class="sourceLine" id="cb19-9" title="9">  <span class="at">const</span> mat&amp; U,</a>
<a class="sourceLine" id="cb19-10" title="10">  <span class="at">const</span> rowvec&amp; d,</a>
<a class="sourceLine" id="cb19-11" title="11">  <span class="at">const</span> mat&amp; V,</a>
<a class="sourceLine" id="cb19-12" title="12">  <span class="at">const</span> vec&amp; row,</a>
<a class="sourceLine" id="cb19-13" title="13">  <span class="at">const</span> vec&amp; col,</a>
<a class="sourceLine" id="cb19-14" title="14">  <span class="at">const</span> vec&amp; x) {</a>
<a class="sourceLine" id="cb19-15" title="15">  </a>
<a class="sourceLine" id="cb19-16" title="16">  <span class="dt">int</span> i, j;</a>
<a class="sourceLine" id="cb19-17" title="17">  <span class="dt">double</span> z_ij;</a>
<a class="sourceLine" id="cb19-18" title="18">  </a>
<a class="sourceLine" id="cb19-19" title="19">  vec zx = zeros&lt;vec&gt;(U.n_rows);</a>
<a class="sourceLine" id="cb19-20" title="20">  </a>
<a class="sourceLine" id="cb19-21" title="21">  <span class="cf">for</span> (<span class="dt">int</span> idx = <span class="dv">0</span>; idx &lt; row.n_elem; idx++) {</a>
<a class="sourceLine" id="cb19-22" title="22">    </a>
<a class="sourceLine" id="cb19-23" title="23">    i = row(idx);</a>
<a class="sourceLine" id="cb19-24" title="24">    j = col(idx);</a>
<a class="sourceLine" id="cb19-25" title="25">    </a>
<a class="sourceLine" id="cb19-26" title="26">    <span class="co">// % does elementwise multiplication in Armadillo</span></a>
<a class="sourceLine" id="cb19-27" title="27">    <span class="co">// accu() gives the sum of elements of resulting vector</span></a>
<a class="sourceLine" id="cb19-28" title="28">    z_ij = accu(U.row(i) % d % V.row(j));</a>
<a class="sourceLine" id="cb19-29" title="29">    </a>
<a class="sourceLine" id="cb19-30" title="30">    zx(i) += x(j) * z_ij;</a>
<a class="sourceLine" id="cb19-31" title="31">  }</a>
<a class="sourceLine" id="cb19-32" title="32">  </a>
<a class="sourceLine" id="cb19-33" title="33">  <span class="cf">return</span> zx;</a>
<a class="sourceLine" id="cb19-34" title="34">}</a></code></pre></div>
<div class="sourceCode" id="cb20"><html><body><pre class="r"><span class="co"># wrap with slightly nicer interface</span>
<span class="no">masked_svd_times_x_cpp</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">s</span>, <span class="no">mask</span>, <span class="no">x</span>) {
  <span class="fu"><a href="https://rdrr.io/r/base/drop.html">drop</a></span>(<span class="fu">masked_svd_times_x_impl</span>(<span class="no">s</span>$<span class="no">u</span>, <span class="no">s</span>$<span class="no">d</span>, <span class="no">s</span>$<span class="no">v</span>, <span class="no">mask</span>@<span class="kw">i</span>, <span class="no">mask</span>@<span class="kw">j</span>, <span class="no">x</span>))
}</pre></body></html></div>
<div class="sourceCode" id="cb21"><html><body><pre class="r"><span class="kw pkg">bench</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/bench/man/mark.html">mark</a></span>(
  <span class="fu">masked_svd_times_x_cpp</span>(<span class="no">s</span>, <span class="no">Y</span>, <span class="no">x</span>),
  <span class="fu">masked_svd_times_x</span>(<span class="no">s</span>, <span class="no">Y</span>, <span class="no">x</span>)
)</pre></body></html></div>
<p>TODO:</p>
<ul>
<li>the tranpose multiplication</li>
<li>the average singular value calculation</li>
</ul>
<p>Recall that to calculate the average singular value we want</p>
<p><span class="math display">\[\begin{align}
||\tilde M^{(t)}||_F^2
&amp;= \left \Vert M \right \Vert_F^2 + 
  \sum_{i = 1}^r \lambda_i^2 - 
  \left \Vert Z_t \odot Y \right \Vert_F^2
\end{align}\]</span></p>
<p>This is the other computationally intensive part so let’s write it up in Armadillo as well</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1"><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span></a>
<a class="sourceLine" id="cb22-2" title="2"></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="kw">using</span> <span class="kw">namespace</span> arma;</a>
<a class="sourceLine" id="cb22-4" title="4"></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span></a>
<a class="sourceLine" id="cb22-6" title="6"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb22-7" title="7"></a>
<a class="sourceLine" id="cb22-8" title="8"><span class="dt">double</span> p_omega_f_norm_impl(</a>
<a class="sourceLine" id="cb22-9" title="9">      <span class="at">const</span> mat&amp; U,</a>
<a class="sourceLine" id="cb22-10" title="10">      <span class="at">const</span> rowvec&amp; d,</a>
<a class="sourceLine" id="cb22-11" title="11">      <span class="at">const</span> mat&amp; V,</a>
<a class="sourceLine" id="cb22-12" title="12">      <span class="at">const</span> vec&amp; row,</a>
<a class="sourceLine" id="cb22-13" title="13">      <span class="at">const</span> vec&amp; col) {</a>
<a class="sourceLine" id="cb22-14" title="14">  </a>
<a class="sourceLine" id="cb22-15" title="15">    <span class="dt">int</span> i, j;</a>
<a class="sourceLine" id="cb22-16" title="16">    <span class="dt">double</span> total = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb22-17" title="17">  </a>
<a class="sourceLine" id="cb22-18" title="18">    <span class="cf">for</span> (<span class="dt">int</span> idx = <span class="dv">0</span>; idx &lt; row.n_elem; idx++) {</a>
<a class="sourceLine" id="cb22-19" title="19">  </a>
<a class="sourceLine" id="cb22-20" title="20">      i = row(idx);</a>
<a class="sourceLine" id="cb22-21" title="21">      j = col(idx);</a>
<a class="sourceLine" id="cb22-22" title="22">  </a>
<a class="sourceLine" id="cb22-23" title="23">      total += accu(U.row(i) % d % V.row(j));</a>
<a class="sourceLine" id="cb22-24" title="24">    }</a>
<a class="sourceLine" id="cb22-25" title="25">  </a>
<a class="sourceLine" id="cb22-26" title="26">    <span class="cf">return</span> total;</a>
<a class="sourceLine" id="cb22-27" title="27">  }</a></code></pre></div>
<div class="sourceCode" id="cb23"><html><body><pre class="r"><span class="co"># wrap with slightly nicer interface</span>
<span class="no">p_omega_f_norm_cpp</span> <span class="kw">&lt;-</span> <span class="kw">function</span>(<span class="no">s</span>, <span class="no">mask</span>) {
  <span class="fu">p_omega_f_norm_impl</span>(<span class="no">s</span>$<span class="no">u</span>, <span class="no">s</span>$<span class="no">d</span>, <span class="no">s</span>$<span class="no">v</span>, <span class="no">mask</span>@<span class="kw">i</span>, <span class="no">mask</span>@<span class="kw">j</span>)
}</pre></body></html></div>
<div class="sourceCode" id="cb24"><html><body><pre class="r"><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html">all.equal</a></span>(
  <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span>(<span class="no">Z</span> * <span class="no">Y</span>),
  <span class="fu">p_omega_f_norm_cpp</span>(<span class="no">s</span>, <span class="no">Y</span>)
)</pre></body></html></div>
<div id="a-naive-solution-the-epsilon-trick" class="section level3">
<h3 class="hasAnchor">
<a href="#a-naive-solution-the-epsilon-trick" class="anchor"></a>A naive solution: the epsilon trick</h3>
<p>issue: we’ve moved back into dense computation land</p>
</div>
<div id="the-memory-efficient-version" class="section level3">
<h3 class="hasAnchor">
<a href="#the-memory-efficient-version" class="anchor"></a>The memory efficient version</h3>
<p>asdf</p>
<p>TODO: don’t coerce to explicit Matrix class as that is not recommended apparently. alternatives?</p>
</div>
</div>
<div id="fully-c-implementation-dense" class="section level2">
<h2 class="hasAnchor">
<a href="#fully-c-implementation-dense" class="anchor"></a>Fully C++ implementation: Dense</h2>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1"><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span></a>
<a class="sourceLine" id="cb25-2" title="2"></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="kw">using</span> <span class="kw">namespace</span> arma;</a>
<a class="sourceLine" id="cb25-4" title="4"></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span></a>
<a class="sourceLine" id="cb25-6" title="6"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb25-7" title="7">Rcpp::List AdaptiveInitialize(<span class="at">const</span> sp_mat&amp; M, <span class="at">const</span> <span class="dt">int</span> r) {</a>
<a class="sourceLine" id="cb25-8" title="8"></a>
<a class="sourceLine" id="cb25-9" title="9">  <span class="co">// coerce to double to avoid integer division</span></a>
<a class="sourceLine" id="cb25-10" title="10">  <span class="dt">double</span> p_hat = <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(M.n_nonzero) / (M.n_cols * M.n_rows);</a>
<a class="sourceLine" id="cb25-11" title="11">  </a>
<a class="sourceLine" id="cb25-12" title="12">  sp_mat MtM = M.t() * M;</a>
<a class="sourceLine" id="cb25-13" title="13">  sp_mat MMt = M * M.t();</a>
<a class="sourceLine" id="cb25-14" title="14">  </a>
<a class="sourceLine" id="cb25-15" title="15">  sp_mat sigma_p = MtM / pow(p_hat, <span class="dv">2</span>) - (<span class="dv">1</span> - p_hat) * diagmat(MtM);</a>
<a class="sourceLine" id="cb25-16" title="16">  sp_mat <span class="dt">sigma_t</span> = MMt / pow(p_hat, <span class="dv">2</span>) - (<span class="dv">1</span> - p_hat) * diagmat(MMt);</a>
<a class="sourceLine" id="cb25-17" title="17"></a>
<a class="sourceLine" id="cb25-18" title="18">  mat U_p, V_p, <span class="dt">U_t</span>, <span class="dt">V_t</span>;</a>
<a class="sourceLine" id="cb25-19" title="19">  vec <span class="va">s_p</span>, <span class="va">s_t</span>;</a>
<a class="sourceLine" id="cb25-20" title="20"></a>
<a class="sourceLine" id="cb25-21" title="21">  svds(U_p, <span class="va">s_p</span>, V_p, sigma_p, r);</a>
<a class="sourceLine" id="cb25-22" title="22">  svds(<span class="dt">U_t</span>, <span class="va">s_t</span>, <span class="dt">V_t</span>, <span class="dt">sigma_t</span>, r);</a>
<a class="sourceLine" id="cb25-23" title="23"></a>
<a class="sourceLine" id="cb25-24" title="24">  <span class="co">// </span><span class="al">TODO</span><span class="co">: this is still the eigenvalue calculation</span></a>
<a class="sourceLine" id="cb25-25" title="25">  <span class="dt">double</span> alpha = (sum(sigma_p.diag()) - sum(<span class="va">s_p</span>)) / (M.n_cols - r);</a>
<a class="sourceLine" id="cb25-26" title="26"></a>
<a class="sourceLine" id="cb25-27" title="27">  vec lambda_hat = sqrt(<span class="va">s_p</span> - alpha) / p_hat;</a>
<a class="sourceLine" id="cb25-28" title="28"></a>
<a class="sourceLine" id="cb25-29" title="29">  mat U_m, V_m;</a>
<a class="sourceLine" id="cb25-30" title="30">  vec <span class="va">s_m</span>;</a>
<a class="sourceLine" id="cb25-31" title="31"></a>
<a class="sourceLine" id="cb25-32" title="32">  svds(U_m, <span class="va">s_m</span>, V_m, M, r);</a>
<a class="sourceLine" id="cb25-33" title="33"></a>
<a class="sourceLine" id="cb25-34" title="34">  <span class="co">// sum(A % B) finds the diag(A^T B) / the diagonal of the cross product</span></a>
<a class="sourceLine" id="cb25-35" title="35">  <span class="co">// sum() does a *column-wise sum*, % an elementwise multiplication</span></a>
<a class="sourceLine" id="cb25-36" title="36">  rowvec u_sign = sign(sum(U_m % <span class="dt">U_t</span>));</a>
<a class="sourceLine" id="cb25-37" title="37">  rowvec v_sign = sign(sum(V_m % V_p));</a>
<a class="sourceLine" id="cb25-38" title="38"></a>
<a class="sourceLine" id="cb25-39" title="39">  rowvec <span class="va">s_hat</span> = u_sign % v_sign;</a>
<a class="sourceLine" id="cb25-40" title="40">  lambda_hat = lambda_hat % conv_to&lt; vec &gt;::from(<span class="va">s_hat</span>);</a>
<a class="sourceLine" id="cb25-41" title="41"></a>
<a class="sourceLine" id="cb25-42" title="42">  <span class="cf">return</span> Rcpp::List::create(Rcpp::Named(<span class="st">"u"</span>) = <span class="dt">U_t</span>,</a>
<a class="sourceLine" id="cb25-43" title="43">                            Rcpp::Named(<span class="st">"d"</span>) = lambda_hat,</a>
<a class="sourceLine" id="cb25-44" title="44">                            Rcpp::Named(<span class="st">"v"</span>) = V_p);</a>
<a class="sourceLine" id="cb25-45" title="45">}</a></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1"><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span></a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="kw">using</span> <span class="kw">namespace</span> arma;</a>
<a class="sourceLine" id="cb26-4" title="4"></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span></a>
<a class="sourceLine" id="cb26-6" title="6"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb26-7" title="7">Rcpp::List AdaptiveImpute(<span class="at">const</span> sp_mat&amp; M, <span class="at">const</span> <span class="dt">int</span> r) {</a>
<a class="sourceLine" id="cb26-8" title="8">  </a>
<a class="sourceLine" id="cb26-9" title="9">  <span class="at">const</span> <span class="dt">double</span> EPSILON = <span class="fl">0.000001</span>;</a>
<a class="sourceLine" id="cb26-10" title="10">  </a>
<a class="sourceLine" id="cb26-11" title="11">  </a>
<a class="sourceLine" id="cb26-12" title="12">  </a>
<a class="sourceLine" id="cb26-13" title="13">  s &lt;- adaptive_initialize(M, r)</a>
<a class="sourceLine" id="cb26-14" title="14">  Z &lt;- s<span class="er">$</span>u %*% diag(s<span class="er">$</span>d) %*% t(s<span class="er">$</span>v)  <span class="er"># line 1</span></a>
<a class="sourceLine" id="cb26-15" title="15">  delta &lt;- Inf</a>
<a class="sourceLine" id="cb26-16" title="16">  </a>
<a class="sourceLine" id="cb26-17" title="17">  <span class="cf">while</span> (delta &gt; epsilon) {</a>
<a class="sourceLine" id="cb26-18" title="18">    </a>
<a class="sourceLine" id="cb26-19" title="19">    y &lt;- as(M, <span class="st">"lgCMatrix"</span>)  <span class="er"># indicator if entry of M observed</span></a>
<a class="sourceLine" id="cb26-20" title="20">    M_tilde &lt;- M + Z * (<span class="dv">1</span> - y)  <span class="er"># line 3</span></a>
<a class="sourceLine" id="cb26-21" title="21">    </a>
<a class="sourceLine" id="cb26-22" title="22">    svd_M &lt;- svds(M_tilde, r)</a>
<a class="sourceLine" id="cb26-23" title="23">    </a>
<a class="sourceLine" id="cb26-24" title="24">    u_hat &lt;- svd_M<span class="er">$</span>u  <span class="er"># line 4</span></a>
<a class="sourceLine" id="cb26-25" title="25">    v_hat &lt;- svd_M<span class="er">$</span>v  <span class="er"># line 5</span></a>
<a class="sourceLine" id="cb26-26" title="26">    </a>
<a class="sourceLine" id="cb26-27" title="27">    d &lt;- ncol(M)</a>
<a class="sourceLine" id="cb26-28" title="28">    </a>
<a class="sourceLine" id="cb26-29" title="29">    alpha &lt;- (sum(M_tilde^<span class="dv">2</span>) - sum(svd_M<span class="er">$</span>d^<span class="dv">2</span>)) / (d - r)  <span class="er"># line 6</span></a>
<a class="sourceLine" id="cb26-30" title="30">    </a>
<a class="sourceLine" id="cb26-31" title="31">    lambda_hat &lt;- sqrt(svd_M<span class="er">$</span>d^<span class="dv">2</span> - alpha)  <span class="er"># line 7</span></a>
<a class="sourceLine" id="cb26-32" title="32">    </a>
<a class="sourceLine" id="cb26-33" title="33">    Z_new &lt;- u_hat %*% diag(lambda_hat) %*% t(v_hat)</a>
<a class="sourceLine" id="cb26-34" title="34">    </a>
<a class="sourceLine" id="cb26-35" title="35">    delta &lt;- sum((Z_new - Z)^<span class="dv">2</span>) / sum(Z^<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb26-36" title="36">    Z &lt;- Z_new</a>
<a class="sourceLine" id="cb26-37" title="37">    </a>
<a class="sourceLine" id="cb26-38" title="38">    print(glue::glue(<span class="st">"delta: {round(delta, 8)}, alpha: {round(alpha, 3)}"</span>))</a>
<a class="sourceLine" id="cb26-39" title="39">  }</a>
<a class="sourceLine" id="cb26-40" title="40">  </a>
<a class="sourceLine" id="cb26-41" title="41">  Z</a>
<a class="sourceLine" id="cb26-42" title="42">}</a></code></pre></div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by <a href="https://alexpghayes.com">Alex Hayes</a>, Juhee Cho, Donggyu Kim, <a href="http://pages.stat.wisc.edu/~karlrohe/">Karl Rohe</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
